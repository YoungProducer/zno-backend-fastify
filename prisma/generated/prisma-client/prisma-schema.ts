// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateSubject {
  count: Int!
}

type AggregateSubjectConfig {
  count: Int!
}

type AggregateTestSuite {
  count: Int!
}

type AggregateTestSuiteImage {
  count: Int!
}

type AggregateToken {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Answer {
  taskId: Int!
  answer: String!
}

input AnswerCreateInput {
  taskId: Int!
  answer: String!
}

input AnswerCreateManyInput {
  create: [AnswerCreateInput!]
}

input AnswerRestrictedWhereInput {
  taskId: Int
  taskId_not: Int
  taskId_in: [Int!]
  taskId_not_in: [Int!]
  taskId_lt: Int
  taskId_lte: Int
  taskId_gt: Int
  taskId_gte: Int
  answer: String
  answer_not: String
  answer_in: [String!]
  answer_not_in: [String!]
  answer_lt: String
  answer_lte: String
  answer_gt: String
  answer_gte: String
  answer_contains: String
  answer_not_contains: String
  answer_starts_with: String
  answer_not_starts_with: String
  answer_ends_with: String
  answer_not_ends_with: String
  AND: [AnswerRestrictedWhereInput!]
}

input AnswerScalarWhereInput {
  taskId: Int
  taskId_not: Int
  taskId_in: [Int!]
  taskId_not_in: [Int!]
  taskId_lt: Int
  taskId_lte: Int
  taskId_gt: Int
  taskId_gte: Int
  answer: String
  answer_not: String
  answer_in: [String!]
  answer_not_in: [String!]
  answer_lt: String
  answer_lte: String
  answer_gt: String
  answer_gte: String
  answer_contains: String
  answer_not_contains: String
  answer_starts_with: String
  answer_not_starts_with: String
  answer_ends_with: String
  answer_not_ends_with: String
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
}

input AnswerUpdateManyDataInput {
  taskId: Int
  answer: String
}

input AnswerUpdateManyInput {
  create: [AnswerCreateInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyWithWhereNestedInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyDataInput!
}

input AnswerWhereInput {
  taskId: Int
  taskId_not: Int
  taskId_in: [Int!]
  taskId_not_in: [Int!]
  taskId_lt: Int
  taskId_lte: Int
  taskId_gt: Int
  taskId_gte: Int
  answer: String
  answer_not: String
  answer_in: [String!]
  answer_not_in: [String!]
  answer_lt: String
  answer_lte: String
  answer_gt: String
  answer_gte: String
  answer_contains: String
  answer_not_contains: String
  answer_starts_with: String
  answer_not_starts_with: String
  answer_ends_with: String
  answer_not_ends_with: String
  AND: [AnswerWhereInput!]
}

type BatchPayload {
  count: Long!
}

type Exams {
  trainings: [String!]!
  sessions: [String!]!
}

input ExamsCreateInput {
  trainings: ExamsCreatetrainingsInput
  sessions: ExamsCreatesessionsInput
}

input ExamsCreateOneInput {
  create: ExamsCreateInput
}

input ExamsCreatesessionsInput {
  set: [String!]
}

input ExamsCreatetrainingsInput {
  set: [String!]
}

input ExamsUpdateDataInput {
  trainings: ExamsUpdatetrainingsInput
  sessions: ExamsUpdatesessionsInput
}

input ExamsUpdateOneInput {
  create: ExamsCreateInput
  update: ExamsUpdateDataInput
  upsert: ExamsUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input ExamsUpdatesessionsInput {
  set: [String!]
}

input ExamsUpdatetrainingsInput {
  set: [String!]
}

input ExamsUpsertNestedInput {
  update: ExamsUpdateDataInput!
  create: ExamsCreateInput!
}

input ExamsWhereInput {
  AND: [ExamsWhereInput!]
}

scalar Long

type Mutation {
  createSubject(data: SubjectCreateInput!): Subject!
  updateSubject(data: SubjectUpdateInput!, where: SubjectWhereUniqueInput!): Subject
  updateManySubjects(data: SubjectUpdateManyMutationInput!, where: SubjectWhereInput): BatchPayload!
  upsertSubject(where: SubjectWhereUniqueInput!, create: SubjectCreateInput!, update: SubjectUpdateInput!): Subject!
  deleteSubject(where: SubjectWhereUniqueInput!): Subject
  deleteManySubjects(where: SubjectWhereInput): BatchPayload!
  createSubjectConfig(data: SubjectConfigCreateInput!): SubjectConfig!
  updateSubjectConfig(data: SubjectConfigUpdateInput!, where: SubjectConfigWhereUniqueInput!): SubjectConfig
  updateManySubjectConfigs(data: SubjectConfigUpdateManyMutationInput!, where: SubjectConfigWhereInput): BatchPayload!
  upsertSubjectConfig(where: SubjectConfigWhereUniqueInput!, create: SubjectConfigCreateInput!, update: SubjectConfigUpdateInput!): SubjectConfig!
  deleteSubjectConfig(where: SubjectConfigWhereUniqueInput!): SubjectConfig
  deleteManySubjectConfigs(where: SubjectConfigWhereInput): BatchPayload!
  createTestSuite(data: TestSuiteCreateInput!): TestSuite!
  updateTestSuite(data: TestSuiteUpdateInput!, where: TestSuiteWhereUniqueInput!): TestSuite
  updateManyTestSuites(data: TestSuiteUpdateManyMutationInput!, where: TestSuiteWhereInput): BatchPayload!
  upsertTestSuite(where: TestSuiteWhereUniqueInput!, create: TestSuiteCreateInput!, update: TestSuiteUpdateInput!): TestSuite!
  deleteTestSuite(where: TestSuiteWhereUniqueInput!): TestSuite
  deleteManyTestSuites(where: TestSuiteWhereInput): BatchPayload!
  createTestSuiteImage(data: TestSuiteImageCreateInput!): TestSuiteImage!
  updateTestSuiteImage(data: TestSuiteImageUpdateInput!, where: TestSuiteImageWhereUniqueInput!): TestSuiteImage
  updateManyTestSuiteImages(data: TestSuiteImageUpdateManyMutationInput!, where: TestSuiteImageWhereInput): BatchPayload!
  upsertTestSuiteImage(where: TestSuiteImageWhereUniqueInput!, create: TestSuiteImageCreateInput!, update: TestSuiteImageUpdateInput!): TestSuiteImage!
  deleteTestSuiteImage(where: TestSuiteImageWhereUniqueInput!): TestSuiteImage
  deleteManyTestSuiteImages(where: TestSuiteImageWhereInput): BatchPayload!
  createToken(data: TokenCreateInput!): Token!
  updateToken(data: TokenUpdateInput!, where: TokenWhereUniqueInput!): Token
  updateManyTokens(data: TokenUpdateManyMutationInput!, where: TokenWhereInput): BatchPayload!
  upsertToken(where: TokenWhereUniqueInput!, create: TokenCreateInput!, update: TokenUpdateInput!): Token!
  deleteToken(where: TokenWhereUniqueInput!): Token
  deleteManyTokens(where: TokenWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  subject(where: SubjectWhereUniqueInput!): Subject
  subjects(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject]!
  subjectsConnection(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubjectConnection!
  subjectConfig(where: SubjectConfigWhereUniqueInput!): SubjectConfig
  subjectConfigs(where: SubjectConfigWhereInput, orderBy: SubjectConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubjectConfig]!
  subjectConfigsConnection(where: SubjectConfigWhereInput, orderBy: SubjectConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubjectConfigConnection!
  testSuite(where: TestSuiteWhereUniqueInput!): TestSuite
  testSuites(where: TestSuiteWhereInput, orderBy: TestSuiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TestSuite]!
  testSuitesConnection(where: TestSuiteWhereInput, orderBy: TestSuiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestSuiteConnection!
  testSuiteImage(where: TestSuiteImageWhereUniqueInput!): TestSuiteImage
  testSuiteImages(where: TestSuiteImageWhereInput, orderBy: TestSuiteImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TestSuiteImage]!
  testSuiteImagesConnection(where: TestSuiteImageWhereInput, orderBy: TestSuiteImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestSuiteImageConnection!
  token(where: TokenWhereUniqueInput!): Token
  tokens(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Token]!
  tokensConnection(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TokenConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  DEFAULT_USER
}

type Subject {
  id: ID!
  name: String!
  isSubSubject: Boolean!
  parent: Subject
  image: String
  config: SubjectConfig
}

type SubjectConfig {
  id: ID!
  subject: Subject!
  themes: [String!]!
  subSubjects: [SubSubject!]
  exams: Exams
}

type SubjectConfigConnection {
  pageInfo: PageInfo!
  edges: [SubjectConfigEdge]!
  aggregate: AggregateSubjectConfig!
}

input SubjectConfigCreateInput {
  id: ID
  subject: SubjectCreateOneWithoutConfigInput!
  themes: SubjectConfigCreatethemesInput
  subSubjects: SubSubjectCreateManyInput
  exams: ExamsCreateOneInput
}

input SubjectConfigCreateOneWithoutSubjectInput {
  create: SubjectConfigCreateWithoutSubjectInput
  connect: SubjectConfigWhereUniqueInput
}

input SubjectConfigCreatethemesInput {
  set: [String!]
}

input SubjectConfigCreateWithoutSubjectInput {
  id: ID
  themes: SubjectConfigCreatethemesInput
  subSubjects: SubSubjectCreateManyInput
  exams: ExamsCreateOneInput
}

type SubjectConfigEdge {
  node: SubjectConfig!
  cursor: String!
}

enum SubjectConfigOrderByInput {
  id_ASC
  id_DESC
}

type SubjectConfigPreviousValues {
  id: ID!
  themes: [String!]!
}

type SubjectConfigSubscriptionPayload {
  mutation: MutationType!
  node: SubjectConfig
  updatedFields: [String!]
  previousValues: SubjectConfigPreviousValues
}

input SubjectConfigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubjectConfigWhereInput
  AND: [SubjectConfigSubscriptionWhereInput!]
}

input SubjectConfigUpdateInput {
  subject: SubjectUpdateOneRequiredWithoutConfigInput
  themes: SubjectConfigUpdatethemesInput
  subSubjects: SubSubjectUpdateManyInput
  exams: ExamsUpdateOneInput
}

input SubjectConfigUpdateManyMutationInput {
  themes: SubjectConfigUpdatethemesInput
}

input SubjectConfigUpdateOneWithoutSubjectInput {
  create: SubjectConfigCreateWithoutSubjectInput
  update: SubjectConfigUpdateWithoutSubjectDataInput
  upsert: SubjectConfigUpsertWithoutSubjectInput
  delete: Boolean
  disconnect: Boolean
  connect: SubjectConfigWhereUniqueInput
}

input SubjectConfigUpdatethemesInput {
  set: [String!]
}

input SubjectConfigUpdateWithoutSubjectDataInput {
  themes: SubjectConfigUpdatethemesInput
  subSubjects: SubSubjectUpdateManyInput
  exams: ExamsUpdateOneInput
}

input SubjectConfigUpsertWithoutSubjectInput {
  update: SubjectConfigUpdateWithoutSubjectDataInput!
  create: SubjectConfigCreateWithoutSubjectInput!
}

input SubjectConfigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subject: SubjectWhereInput
  subSubjects_some: SubSubjectWhereInput
  subSubjects_every: SubSubjectRestrictedWhereInput
  subSubjects_none: SubSubjectRestrictedWhereInput
  exams: ExamsWhereInput
  AND: [SubjectConfigWhereInput!]
}

input SubjectConfigWhereUniqueInput {
  id: ID
}

type SubjectConnection {
  pageInfo: PageInfo!
  edges: [SubjectEdge]!
  aggregate: AggregateSubject!
}

input SubjectCreateInput {
  id: ID
  name: String!
  isSubSubject: Boolean
  parent: SubjectCreateOneInput
  image: String
  config: SubjectConfigCreateOneWithoutSubjectInput
}

input SubjectCreateOneInput {
  create: SubjectCreateInput
  connect: SubjectWhereUniqueInput
}

input SubjectCreateOneWithoutConfigInput {
  create: SubjectCreateWithoutConfigInput
  connect: SubjectWhereUniqueInput
}

input SubjectCreateWithoutConfigInput {
  id: ID
  name: String!
  isSubSubject: Boolean
  parent: SubjectCreateOneInput
  image: String
}

type SubjectEdge {
  node: Subject!
  cursor: String!
}

enum SubjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  isSubSubject_ASC
  isSubSubject_DESC
  image_ASC
  image_DESC
}

type SubjectPreviousValues {
  id: ID!
  name: String!
  isSubSubject: Boolean!
  image: String
}

type SubjectSubscriptionPayload {
  mutation: MutationType!
  node: Subject
  updatedFields: [String!]
  previousValues: SubjectPreviousValues
}

input SubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubjectWhereInput
  AND: [SubjectSubscriptionWhereInput!]
}

input SubjectUpdateDataInput {
  name: String
  isSubSubject: Boolean
  parent: SubjectUpdateOneInput
  image: String
  config: SubjectConfigUpdateOneWithoutSubjectInput
}

input SubjectUpdateInput {
  name: String
  isSubSubject: Boolean
  parent: SubjectUpdateOneInput
  image: String
  config: SubjectConfigUpdateOneWithoutSubjectInput
}

input SubjectUpdateManyMutationInput {
  name: String
  isSubSubject: Boolean
  image: String
}

input SubjectUpdateOneInput {
  create: SubjectCreateInput
  update: SubjectUpdateDataInput
  upsert: SubjectUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SubjectWhereUniqueInput
}

input SubjectUpdateOneRequiredInput {
  create: SubjectCreateInput
  update: SubjectUpdateDataInput
  upsert: SubjectUpsertNestedInput
  connect: SubjectWhereUniqueInput
}

input SubjectUpdateOneRequiredWithoutConfigInput {
  create: SubjectCreateWithoutConfigInput
  update: SubjectUpdateWithoutConfigDataInput
  upsert: SubjectUpsertWithoutConfigInput
  connect: SubjectWhereUniqueInput
}

input SubjectUpdateWithoutConfigDataInput {
  name: String
  isSubSubject: Boolean
  parent: SubjectUpdateOneInput
  image: String
}

input SubjectUpsertNestedInput {
  update: SubjectUpdateDataInput!
  create: SubjectCreateInput!
}

input SubjectUpsertWithoutConfigInput {
  update: SubjectUpdateWithoutConfigDataInput!
  create: SubjectCreateWithoutConfigInput!
}

input SubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isSubSubject: Boolean
  isSubSubject_not: Boolean
  parent: SubjectWhereInput
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  config: SubjectConfigWhereInput
  AND: [SubjectWhereInput!]
}

input SubjectWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  subject(where: SubjectSubscriptionWhereInput): SubjectSubscriptionPayload
  subjectConfig(where: SubjectConfigSubscriptionWhereInput): SubjectConfigSubscriptionPayload
  testSuite(where: TestSuiteSubscriptionWhereInput): TestSuiteSubscriptionPayload
  testSuiteImage(where: TestSuiteImageSubscriptionWhereInput): TestSuiteImageSubscriptionPayload
  token(where: TokenSubscriptionWhereInput): TokenSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type SubSubject {
  subject: Subject!
  themes: [String!]!
}

input SubSubjectCreateInput {
  subject: SubjectCreateOneInput!
  themes: SubSubjectCreatethemesInput
}

input SubSubjectCreateManyInput {
  create: [SubSubjectCreateInput!]
}

input SubSubjectCreatethemesInput {
  set: [String!]
}

input SubSubjectRestrictedWhereInput {
  AND: [SubSubjectRestrictedWhereInput!]
}

input SubSubjectScalarWhereInput {
  AND: [SubSubjectScalarWhereInput!]
  OR: [SubSubjectScalarWhereInput!]
  NOT: [SubSubjectScalarWhereInput!]
}

input SubSubjectUpdateManyDataInput {
  themes: SubSubjectUpdatethemesInput
}

input SubSubjectUpdateManyInput {
  create: [SubSubjectCreateInput!]
  deleteMany: [SubSubjectScalarWhereInput!]
  updateMany: [SubSubjectUpdateManyWithWhereNestedInput!]
}

input SubSubjectUpdateManyWithWhereNestedInput {
  where: SubSubjectScalarWhereInput!
  data: SubSubjectUpdateManyDataInput!
}

input SubSubjectUpdatethemesInput {
  set: [String!]
}

input SubSubjectWhereInput {
  subject: SubjectWhereInput
  AND: [SubSubjectWhereInput!]
}

type TestSuite {
  id: ID!
  subject: Subject!
  subSubject: Subject
  theme: String
  session: String
  training: String
  answers: [Answer!]
  tasks(where: TestSuiteImageWhereInput, orderBy: TestSuiteImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TestSuiteImage!]
  explanations(where: TestSuiteImageWhereInput, orderBy: TestSuiteImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TestSuiteImage!]
  path: String!
}

type TestSuiteConnection {
  pageInfo: PageInfo!
  edges: [TestSuiteEdge]!
  aggregate: AggregateTestSuite!
}

input TestSuiteCreateInput {
  id: ID
  subject: SubjectCreateOneInput!
  subSubject: SubjectCreateOneInput
  theme: String
  session: String
  training: String
  answers: AnswerCreateManyInput
  tasks: TestSuiteImageCreateManyWithoutTestSuiteInput
  explanations: TestSuiteImageCreateManyInput
  path: String!
}

input TestSuiteCreateOneWithoutTasksInput {
  create: TestSuiteCreateWithoutTasksInput
  connect: TestSuiteWhereUniqueInput
}

input TestSuiteCreateWithoutTasksInput {
  id: ID
  subject: SubjectCreateOneInput!
  subSubject: SubjectCreateOneInput
  theme: String
  session: String
  training: String
  answers: AnswerCreateManyInput
  explanations: TestSuiteImageCreateManyInput
  path: String!
}

type TestSuiteEdge {
  node: TestSuite!
  cursor: String!
}

type TestSuiteImage {
  id: ID!
  taskId: Int!
  testSuite: TestSuite!
  image: String!
}

type TestSuiteImageConnection {
  pageInfo: PageInfo!
  edges: [TestSuiteImageEdge]!
  aggregate: AggregateTestSuiteImage!
}

input TestSuiteImageCreateInput {
  id: ID
  taskId: Int!
  testSuite: TestSuiteCreateOneWithoutTasksInput!
  image: String!
}

input TestSuiteImageCreateManyInput {
  create: [TestSuiteImageCreateInput!]
  connect: [TestSuiteImageWhereUniqueInput!]
}

input TestSuiteImageCreateManyWithoutTestSuiteInput {
  create: [TestSuiteImageCreateWithoutTestSuiteInput!]
  connect: [TestSuiteImageWhereUniqueInput!]
}

input TestSuiteImageCreateWithoutTestSuiteInput {
  id: ID
  taskId: Int!
  image: String!
}

type TestSuiteImageEdge {
  node: TestSuiteImage!
  cursor: String!
}

enum TestSuiteImageOrderByInput {
  id_ASC
  id_DESC
  taskId_ASC
  taskId_DESC
  image_ASC
  image_DESC
}

type TestSuiteImagePreviousValues {
  id: ID!
  taskId: Int!
  image: String!
}

input TestSuiteImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  taskId: Int
  taskId_not: Int
  taskId_in: [Int!]
  taskId_not_in: [Int!]
  taskId_lt: Int
  taskId_lte: Int
  taskId_gt: Int
  taskId_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [TestSuiteImageScalarWhereInput!]
  OR: [TestSuiteImageScalarWhereInput!]
  NOT: [TestSuiteImageScalarWhereInput!]
}

type TestSuiteImageSubscriptionPayload {
  mutation: MutationType!
  node: TestSuiteImage
  updatedFields: [String!]
  previousValues: TestSuiteImagePreviousValues
}

input TestSuiteImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestSuiteImageWhereInput
  AND: [TestSuiteImageSubscriptionWhereInput!]
}

input TestSuiteImageUpdateDataInput {
  taskId: Int
  testSuite: TestSuiteUpdateOneRequiredWithoutTasksInput
  image: String
}

input TestSuiteImageUpdateInput {
  taskId: Int
  testSuite: TestSuiteUpdateOneRequiredWithoutTasksInput
  image: String
}

input TestSuiteImageUpdateManyDataInput {
  taskId: Int
  image: String
}

input TestSuiteImageUpdateManyInput {
  create: [TestSuiteImageCreateInput!]
  update: [TestSuiteImageUpdateWithWhereUniqueNestedInput!]
  upsert: [TestSuiteImageUpsertWithWhereUniqueNestedInput!]
  delete: [TestSuiteImageWhereUniqueInput!]
  connect: [TestSuiteImageWhereUniqueInput!]
  set: [TestSuiteImageWhereUniqueInput!]
  disconnect: [TestSuiteImageWhereUniqueInput!]
  deleteMany: [TestSuiteImageScalarWhereInput!]
  updateMany: [TestSuiteImageUpdateManyWithWhereNestedInput!]
}

input TestSuiteImageUpdateManyMutationInput {
  taskId: Int
  image: String
}

input TestSuiteImageUpdateManyWithoutTestSuiteInput {
  create: [TestSuiteImageCreateWithoutTestSuiteInput!]
  delete: [TestSuiteImageWhereUniqueInput!]
  connect: [TestSuiteImageWhereUniqueInput!]
  set: [TestSuiteImageWhereUniqueInput!]
  disconnect: [TestSuiteImageWhereUniqueInput!]
  update: [TestSuiteImageUpdateWithWhereUniqueWithoutTestSuiteInput!]
  upsert: [TestSuiteImageUpsertWithWhereUniqueWithoutTestSuiteInput!]
  deleteMany: [TestSuiteImageScalarWhereInput!]
  updateMany: [TestSuiteImageUpdateManyWithWhereNestedInput!]
}

input TestSuiteImageUpdateManyWithWhereNestedInput {
  where: TestSuiteImageScalarWhereInput!
  data: TestSuiteImageUpdateManyDataInput!
}

input TestSuiteImageUpdateWithoutTestSuiteDataInput {
  taskId: Int
  image: String
}

input TestSuiteImageUpdateWithWhereUniqueNestedInput {
  where: TestSuiteImageWhereUniqueInput!
  data: TestSuiteImageUpdateDataInput!
}

input TestSuiteImageUpdateWithWhereUniqueWithoutTestSuiteInput {
  where: TestSuiteImageWhereUniqueInput!
  data: TestSuiteImageUpdateWithoutTestSuiteDataInput!
}

input TestSuiteImageUpsertWithWhereUniqueNestedInput {
  where: TestSuiteImageWhereUniqueInput!
  update: TestSuiteImageUpdateDataInput!
  create: TestSuiteImageCreateInput!
}

input TestSuiteImageUpsertWithWhereUniqueWithoutTestSuiteInput {
  where: TestSuiteImageWhereUniqueInput!
  update: TestSuiteImageUpdateWithoutTestSuiteDataInput!
  create: TestSuiteImageCreateWithoutTestSuiteInput!
}

input TestSuiteImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  taskId: Int
  taskId_not: Int
  taskId_in: [Int!]
  taskId_not_in: [Int!]
  taskId_lt: Int
  taskId_lte: Int
  taskId_gt: Int
  taskId_gte: Int
  testSuite: TestSuiteWhereInput
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [TestSuiteImageWhereInput!]
}

input TestSuiteImageWhereUniqueInput {
  id: ID
  image: String
}

enum TestSuiteOrderByInput {
  id_ASC
  id_DESC
  theme_ASC
  theme_DESC
  session_ASC
  session_DESC
  training_ASC
  training_DESC
  path_ASC
  path_DESC
}

type TestSuitePreviousValues {
  id: ID!
  theme: String
  session: String
  training: String
  path: String!
}

type TestSuiteSubscriptionPayload {
  mutation: MutationType!
  node: TestSuite
  updatedFields: [String!]
  previousValues: TestSuitePreviousValues
}

input TestSuiteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestSuiteWhereInput
  AND: [TestSuiteSubscriptionWhereInput!]
}

input TestSuiteUpdateInput {
  subject: SubjectUpdateOneRequiredInput
  subSubject: SubjectUpdateOneInput
  theme: String
  session: String
  training: String
  answers: AnswerUpdateManyInput
  tasks: TestSuiteImageUpdateManyWithoutTestSuiteInput
  explanations: TestSuiteImageUpdateManyInput
  path: String
}

input TestSuiteUpdateManyMutationInput {
  theme: String
  session: String
  training: String
  path: String
}

input TestSuiteUpdateOneRequiredWithoutTasksInput {
  create: TestSuiteCreateWithoutTasksInput
  update: TestSuiteUpdateWithoutTasksDataInput
  upsert: TestSuiteUpsertWithoutTasksInput
  connect: TestSuiteWhereUniqueInput
}

input TestSuiteUpdateWithoutTasksDataInput {
  subject: SubjectUpdateOneRequiredInput
  subSubject: SubjectUpdateOneInput
  theme: String
  session: String
  training: String
  answers: AnswerUpdateManyInput
  explanations: TestSuiteImageUpdateManyInput
  path: String
}

input TestSuiteUpsertWithoutTasksInput {
  update: TestSuiteUpdateWithoutTasksDataInput!
  create: TestSuiteCreateWithoutTasksInput!
}

input TestSuiteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subject: SubjectWhereInput
  subSubject: SubjectWhereInput
  theme: String
  theme_not: String
  theme_in: [String!]
  theme_not_in: [String!]
  theme_lt: String
  theme_lte: String
  theme_gt: String
  theme_gte: String
  theme_contains: String
  theme_not_contains: String
  theme_starts_with: String
  theme_not_starts_with: String
  theme_ends_with: String
  theme_not_ends_with: String
  session: String
  session_not: String
  session_in: [String!]
  session_not_in: [String!]
  session_lt: String
  session_lte: String
  session_gt: String
  session_gte: String
  session_contains: String
  session_not_contains: String
  session_starts_with: String
  session_not_starts_with: String
  session_ends_with: String
  session_not_ends_with: String
  training: String
  training_not: String
  training_in: [String!]
  training_not_in: [String!]
  training_lt: String
  training_lte: String
  training_gt: String
  training_gte: String
  training_contains: String
  training_not_contains: String
  training_starts_with: String
  training_not_starts_with: String
  training_ends_with: String
  training_not_ends_with: String
  answers_some: AnswerWhereInput
  answers_every: AnswerRestrictedWhereInput
  answers_none: AnswerRestrictedWhereInput
  tasks_some: TestSuiteImageWhereInput
  explanations_some: TestSuiteImageWhereInput
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  AND: [TestSuiteWhereInput!]
}

input TestSuiteWhereUniqueInput {
  id: ID
  path: String
}

type Token {
  id: ID!
  token: String!
  loginId: String!
  user: User!
}

type TokenConnection {
  pageInfo: PageInfo!
  edges: [TokenEdge]!
  aggregate: AggregateToken!
}

input TokenCreateInput {
  id: ID
  token: String!
  loginId: String!
  user: UserCreateOneWithoutRefreshTokensInput!
}

input TokenCreateManyWithoutUserInput {
  create: [TokenCreateWithoutUserInput!]
  connect: [TokenWhereUniqueInput!]
}

input TokenCreateWithoutUserInput {
  id: ID
  token: String!
  loginId: String!
}

type TokenEdge {
  node: Token!
  cursor: String!
}

enum TokenOrderByInput {
  id_ASC
  id_DESC
  token_ASC
  token_DESC
  loginId_ASC
  loginId_DESC
}

type TokenPreviousValues {
  id: ID!
  token: String!
  loginId: String!
}

input TokenScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  loginId: String
  loginId_not: String
  loginId_in: [String!]
  loginId_not_in: [String!]
  loginId_lt: String
  loginId_lte: String
  loginId_gt: String
  loginId_gte: String
  loginId_contains: String
  loginId_not_contains: String
  loginId_starts_with: String
  loginId_not_starts_with: String
  loginId_ends_with: String
  loginId_not_ends_with: String
  AND: [TokenScalarWhereInput!]
  OR: [TokenScalarWhereInput!]
  NOT: [TokenScalarWhereInput!]
}

type TokenSubscriptionPayload {
  mutation: MutationType!
  node: Token
  updatedFields: [String!]
  previousValues: TokenPreviousValues
}

input TokenSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TokenWhereInput
  AND: [TokenSubscriptionWhereInput!]
}

input TokenUpdateInput {
  token: String
  loginId: String
  user: UserUpdateOneRequiredWithoutRefreshTokensInput
}

input TokenUpdateManyDataInput {
  token: String
  loginId: String
}

input TokenUpdateManyMutationInput {
  token: String
  loginId: String
}

input TokenUpdateManyWithoutUserInput {
  create: [TokenCreateWithoutUserInput!]
  delete: [TokenWhereUniqueInput!]
  connect: [TokenWhereUniqueInput!]
  set: [TokenWhereUniqueInput!]
  disconnect: [TokenWhereUniqueInput!]
  update: [TokenUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TokenUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TokenScalarWhereInput!]
  updateMany: [TokenUpdateManyWithWhereNestedInput!]
}

input TokenUpdateManyWithWhereNestedInput {
  where: TokenScalarWhereInput!
  data: TokenUpdateManyDataInput!
}

input TokenUpdateWithoutUserDataInput {
  token: String
  loginId: String
}

input TokenUpdateWithWhereUniqueWithoutUserInput {
  where: TokenWhereUniqueInput!
  data: TokenUpdateWithoutUserDataInput!
}

input TokenUpsertWithWhereUniqueWithoutUserInput {
  where: TokenWhereUniqueInput!
  update: TokenUpdateWithoutUserDataInput!
  create: TokenCreateWithoutUserInput!
}

input TokenWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  loginId: String
  loginId_not: String
  loginId_in: [String!]
  loginId_not_in: [String!]
  loginId_lt: String
  loginId_lte: String
  loginId_gt: String
  loginId_gte: String
  loginId_contains: String
  loginId_not_contains: String
  loginId_starts_with: String
  loginId_not_starts_with: String
  loginId_ends_with: String
  loginId_not_ends_with: String
  user: UserWhereInput
  AND: [TokenWhereInput!]
}

input TokenWhereUniqueInput {
  id: ID
  token: String
  loginId: String
}

type User {
  id: ID!
  email: String!
  password: String!
  role: Role!
  refreshTokens(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Token!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  role: Role!
  refreshTokens: TokenCreateManyWithoutUserInput
}

input UserCreateOneWithoutRefreshTokensInput {
  create: UserCreateWithoutRefreshTokensInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutRefreshTokensInput {
  id: ID
  email: String!
  password: String!
  role: Role!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  role: Role!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  role: Role
  refreshTokens: TokenUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  role: Role
}

input UserUpdateOneRequiredWithoutRefreshTokensInput {
  create: UserCreateWithoutRefreshTokensInput
  update: UserUpdateWithoutRefreshTokensDataInput
  upsert: UserUpsertWithoutRefreshTokensInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutRefreshTokensDataInput {
  email: String
  password: String
  role: Role
}

input UserUpsertWithoutRefreshTokensInput {
  update: UserUpdateWithoutRefreshTokensDataInput!
  create: UserCreateWithoutRefreshTokensInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  refreshTokens_some: TokenWhereInput
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`